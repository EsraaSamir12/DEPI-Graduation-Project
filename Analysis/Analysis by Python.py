# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SqxAYq2y-VKrky36BXrL7HagkHf0eoTe
"""

!pip install --quiet pandas numpy matplotlib seaborn openpyxl
print("Libraries installed / ready.")

#  uploading the files
from google.colab import files
uploaded = files.upload()
print("Uploaded files:", list(uploaded.keys()))

# imports and helper functions
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
sns.set(style='whitegrid', rc={'figure.figsize':(10,5)})

# cleaning helpers
def clean_column_name(name):
    if not isinstance(name, str):
        return name
    name = name.replace('\ufeff','')   #
    name = name.replace('ï»¿','')
    name = name.replace('\u200b','')
    name = name.strip()
    return name

def read_file_guess(path):
    """Read csv/xlsx with safe encoding and return cleaned df"""
    try:
        if path.lower().endswith(('.xlsx','.xls')):
            df = pd.read_excel(path)
        else:
            df = pd.read_csv(path, encoding='utf-8-sig')
    except Exception as e:

        df = pd.read_csv(path, encoding='latin1', errors='replace')
    df.columns = [clean_column_name(c) for c in df.columns]
    return df

print("Helpers ready.")

#  loading the files
files_map = {
    'applicants': 'Applicant.csv',
    'applications': 'Applications.csv',
    'scholarship': 'Scholarship.csv',
    'university': 'University.csv',
    'finance_details': 'FinanceDetails.csv',
    'exams': 'Exams.csv',
    'exam_types': 'ExamsType.csv',
    'interviews': 'Interviews.csv',
    'interviewers': 'interviewers.csv',
    'recommendation': 'Recommendation.csv',
    'recommenders': 'recommenders.csv',
    'app_fin_support': 'ApplicationFinancialSupport.csv',
    'financial_types': 'FinancialSupports.csv',
    'payments': 'finalpayment.csv',
    'committee_members': 'Committee Members.csv',
    'committee': 'Committee.csv'
}

data = {}
for key, fname in files_map.items():
    try:
        df = read_file_guess(fname)
        data[key] = df
        print(f"Loaded {fname}: rows={len(df)}, cols={len(df.columns)}")
    except FileNotFoundError:
        print(f"File not found: {fname}  — skip.")
    except Exception as e:
        print(f"Error loading {fname}: {e}")

# Cell E: print columns for key tables (to verify names)
tables_to_check = ['applications','scholarship','university','finance_details','applicants','exams','exam_types']
for t in tables_to_check:
    df = data.get(t)
    if df is None:
        print(f"{t}: NOT LOADED")
    else:
        print(f"\n{t} columns ({len(df.columns)}):")
        for c in df.columns:
            print("  ", repr(c))

# Renaming ScholID in applications to Schol_ID for consistency
data['applications'].rename(columns={'ScholID': 'Schol_ID'}, inplace=True)
print("Renamed ScholID -> Schol_ID successfully.")


print("Updated application columns:")
print(data['applications'].columns.tolist())

# build merged dataset step-by-step
apps = data.get('applications')
applicants = data.get('applicants')
sch = data.get('scholarship')
uni = data.get('university')
fin = data.get('finance_details')
ex = data.get('exams')
exam_types = data.get('exam_types')
iv = data.get('interviews')
rec = data.get('recommendation')
recommenders = data.get('recommenders')
afs = data.get('app_fin_support')
fin_types = data.get('financial_types')


sch_full = sch.copy() if sch is not None else None
if sch_full is not None and uni is not None:


    uni_key = 'Uni_ID' if 'Uni_ID' in uni.columns else ('UniID' if 'UniID' in uni.columns else None)
    sch_key = 'Uni_ID' if 'Uni_ID' in sch_full.columns else ('UniID' if 'UniID' in sch_full.columns else None)
    if uni_key and sch_key:
        sch_full = sch_full.merge(uni, left_on=sch_key, right_on=uni_key, how='left', suffixes=('','_uni'))
        print("Merged scholarship with university.")
    else:
        print("Could not auto-detect Uni key in scholarship/university.")

exam_full = ex.merge(exam_types, left_on='ExamTypeID', right_on='ExamTypeID', how='left') if ex is not None and exam_types is not None else ex

rec_full = None
if rec is not None and recommenders is not None:

    key_rec = 'RecommenderID' if 'RecommenderID' in rec.columns and 'RecommenderID' in recommenders.columns else None
    if key_rec:
        rec_full = rec.merge(recommenders, on=key_rec, how='left')
        print("Merged recommendation with recommenders.")
    else:
        rec_full = rec


merged = apps.copy() if apps is not None else pd.DataFrame()

if merged is not None and applicants is not None and 'ApplicantID' in merged.columns and 'ApplicantID' in applicants.columns:
    merged = merged.merge(applicants, on='ApplicantID', how='left')


sch_left = None
sch_right = None
if merged is not None and sch_full is not None:

    for c in ['ScholID','Schol_ID','Schol_Id','Schol_Id']:
        if c in merged.columns:
            sch_left = c
            break
    for c in ['ScholID','Schol_ID','Schol_Id','Schol_Id']:
        if c in sch_full.columns:
            sch_right = c
            break
    print("Detected scholarship keys:", sch_left, sch_right)
    if sch_left and sch_right:
        merged = merged.merge(sch_full, left_on=sch_left, right_on=sch_right, how='left', suffixes=('','_sch'))
    else:
        print("Scholarship keys not detected automatically; please check column names (run Cell E).")


for df, name in [(exam_full,'exam_full'), (iv,'interviews'), (rec_full,'recommendations'), (afs,'app_fin_support'), (fin_types,'financial_types')]:
    if df is not None and 'ApplicationID' in df.columns and 'ApplicationID' in merged.columns:
        merged = merged.merge(df, on='ApplicationID', how='left', suffixes=('','_'+name))

print("Final merged shape:", merged.shape)
merged.head()

# number of universities per country
if uni is not None:
    col_loc = 'Location' if 'Location' in uni.columns else ('Country' if 'Country' in uni.columns else None)
    col_name = 'University' if 'University' in uni.columns else ('Name' if 'Name' in uni.columns else None)
    if col_loc and col_name:
        df_uni_country = uni.groupby(col_loc)[col_name].nunique().reset_index().rename(columns={col_loc:'Country', col_name:'TotalUniversities'})
        df_uni_country = df_uni_country.sort_values('TotalUniversities', ascending=False)
        display(df_uni_country.head(30))
        df_uni_country.plot(kind='bar', x='Country', y='TotalUniversities', legend=False)
        plt.xticks(rotation=45, ha='right')
        plt.title('Universities per Country')
        plt.show()
    else:
        print("Could not detect University or Location columns in university table.")
else:
    print("University table not loaded.")

print("Loaded dataframes:", list(data.keys()))

# safer manual load for problematic encoding (University.csv)
import pandas as pd


file_path = "University.csv"

try:
    uni = pd.read_csv(file_path, encoding='utf-8-sig')
except UnicodeDecodeError:
    try:
        uni = pd.read_csv(file_path, encoding='latin1')
    except Exception as e:
        uni = pd.read_csv(file_path, encoding='windows-1252')


def clean_column_name(name):
    if not isinstance(name, str):
        return name
    return name.replace('\ufeff','').replace('ï»¿','').strip()

uni.columns = [clean_column_name(c) for c in uni.columns]


print("University table loaded successfully ")
print("Columns:", uni.columns.tolist())


data['university'] = uni

print(data.keys())

#  average university rating per country
if uni is not None:
    rating_col = 'Rating' if 'Rating' in uni.columns else None
    loc_col = 'Location' if 'Location' in uni.columns else ('Country' if 'Country' in uni.columns else None)
    if rating_col and loc_col:
        df = uni.groupby(loc_col)[rating_col].mean().reset_index().rename(columns={loc_col:'Country', rating_col:'AvgRating'}).sort_values('AvgRating', ascending=False)
        display(df.head(30))
    else:
        print("University Rating or Location column not found.")
else:
    print("University table not loaded.")

print("Merged columns:\n", merged.columns.tolist())
print("\nScholarship full columns:\n", sch_full.columns.tolist())

# Scholarships count by host country (using merged table)
if 'Country' in merged.columns and 'Schol_ID' in merged.columns:
    df_sch_country = (
        merged.groupby('Country')['Schol_ID']
        .nunique()
        .reset_index()
        .rename(columns={'Schol_ID': 'TotalScholarships'})
        .sort_values('TotalScholarships', ascending=False)
    )

    print("Top countries by number of scholarships:")
    display(df_sch_country.head(20))

    # Visualization
    df_sch_country.head(15).plot(
        kind='bar',
        x='Country',
        y='TotalScholarships',
        legend=False,
        color='skyblue'
    )
    plt.title('Scholarships by Country (from merged data)')
    plt.xlabel('Country')
    plt.ylabel('Number of Scholarships')
    plt.xticks(rotation=45, ha='right')
    plt.show()
else:
    print("Columns 'Country' or 'Schol_ID' not found in merged table.")

# average university rating per country (uses university table)
if uni is not None:
    rating_col = 'Rating' if 'Rating' in uni.columns else None
    loc_col = 'Location' if 'Location' in uni.columns else ('Country' if 'Country' in uni.columns else None)
    if rating_col and loc_col:
        df = uni.groupby(loc_col)[rating_col].mean().reset_index().rename(columns={loc_col:'Country', rating_col:'AvgRating'}).sort_values('AvgRating', ascending=False)
        display(df.head(30))
    else:
        print("University Rating or Location column not found.")
else:
    print("University table not loaded.")

# top applicant nationalities (international)
if applicants is not None:
    nat_col = 'Nationality' if 'Nationality' in applicants.columns else ('nationality' if 'nationality' in applicants.columns else None)
    if nat_col:
        df_nat = applicants[nat_col].value_counts().reset_index().rename(columns={nat_col:'Nationality', 'count':'Count'})
        display(df_nat.head(20))
        df_nat.head(10).plot(kind='bar', x='Nationality', y='Count', legend=False)
        plt.xticks(rotation=45, ha='right'); plt.title('Top Applicant Nationalities'); plt.show()
    else:
        print("Nationality column not found in applicants.")
else:
    print("Applicants not loaded.")

# Fix column name mismatch (rename nationality to Nationality)
merged.rename(columns={'nationality': 'Nationality'}, inplace=True)
print("Renamed column nationality → Nationality ")

#  local vs international ratio by host country (using merged)
if 'ApplicationID' in merged.columns and 'Nationality' in merged.columns and 'Location' in merged.columns:
    def is_local(n):
        if pd.isna(n): return False
        return bool(str(n).lower().strip() in ['egypt','egyptian','local'])
    merged['IsLocalApplicant'] = merged['Nationality'].apply(is_local)
    df_country = merged.groupby('Location').agg(
        TotalApplications=('ApplicationID','nunique'),
        LocalApplicants=('IsLocalApplicant','sum')
    ).reset_index()
    df_country['IntlApplicants'] = df_country['TotalApplications'] - df_country['LocalApplicants']
    df_country['IntlPct'] = (df_country['IntlApplicants'] / df_country['TotalApplications'] * 100).round(2)
    display(df_country.sort_values('IntlPct', ascending=False).head(30))
else:
    print("Merged table does not contain needed columns (ApplicationID, Nationality, Location).")

print("FinanceDetails columns:\n", data['finance_details'].columns.tolist())

if 'finance_details' in data:
    fin = data['finance_details']

    fin_key = 'FinanceID' if 'FinanceID' in fin.columns else None
    if fin_key and 'FinanceID' in merged.columns:
        merged = merged.merge(fin, on='FinanceID', how='left', suffixes=('','_fin'))
        print("Finance details merged successfully ")
    else:
        print("FinanceID not found in one of the tables.")
else:
    print("Finance details file not loaded.")

print("Merged columns after adding finance details:")
print(merged.columns.tolist())

print("Finance details columns:\n", data['finance_details'].columns.tolist())

#  Average total cost (tuition + living) per country


if 'FinanceID' in merged.columns and 'FinanceID' in data['finance_details'].columns:
    merged = merged.merge(
        data['finance_details'],
        on='FinanceID',
        how='left',
        suffixes=('', '_fin')
    )
    print(" Finance details successfully merged into merged table.")


if 'Tuition' in merged.columns and 'Max Applicant need to pay Living Expense' in merged.columns and 'Country' in merged.columns:
    merged['TotalCost'] = merged['Tuition'].fillna(0) + merged['Max Applicant need to pay Living Expense'].fillna(0)

    df_cost = (
        merged.groupby('Country')['TotalCost']
        .mean()
        .reset_index()
        .rename(columns={'TotalCost': 'AvgTotalCost'})
        .sort_values('AvgTotalCost', ascending=False)
    )

    print(" Average total cost per country (Top 15):")
    display(df_cost.head(15))

    # Visualization
    df_cost.head(15).plot(
        kind='bar',
        x='Country',
        y='AvgTotalCost',
        color='darkcyan',
        legend=False
    )
    plt.title('Average Total Cost (Tuition + Living Expense) by Country')
    plt.xlabel('Country')
    plt.ylabel('Average Total Cost')
    plt.xticks(rotation=45, ha='right')
    plt.show()

else:
    print("⚠️ Still missing one of the required columns:")
    print("Expected: Tuition, Max Applicant need to pay Living Expense, Country")
    print("Available columns:", merged.columns.tolist())

merged['gender'].value_counts().plot(kind='pie', autopct='%1.1f%%', colors=['lightblue','pink'])
plt.title('Gender Distribution among Applicants')
plt.ylabel('')
plt.show()

sns.histplot(merged['GPA'].dropna(), bins=20, kde=True, color='teal')
plt.title('Distribution of Applicant GPA')
plt.xlabel('GPA')
plt.show()

sns.scatterplot(x='Duration', y='Tuition', data=merged, hue='Degree')
plt.title('Tuition vs Program Duration by Degree')
plt.show()

merged['IsFullScholarship'] = merged['Max Scholarship coverage Tuition'] >= merged['Tuition']
merged['IsFullScholarship'].value_counts().plot(kind='bar', color=['gold','lightgrey'])
plt.title('Full vs Partial Scholarships')
plt.xticks([0,1], ['Partial','Full'], rotation=0)
plt.show()

df_passrate = merged.groupby('ExamName')['Result'].value_counts(normalize=True).unstack().fillna(0)*100
df_passrate.plot(kind='bar', stacked=True)
plt.title('Exam Pass/Fail Rates by Exam Type')
plt.ylabel('%')
plt.show()

df_sch_year = merged.groupby('StartYear')['Schol_ID'].nunique().reset_index()
sns.lineplot(x='StartYear', y='Schol_ID', data=df_sch_year, marker='o', color='purple')
plt.title('Scholarships Offered Over Years')
plt.show()

merged['ApplicationYear'] = pd.to_datetime(merged['ApplicationDate']).dt.year
df_year = merged.groupby('ApplicationYear')['ApplicationID'].nunique().reset_index()
sns.lineplot(x='ApplicationYear', y='ApplicationID', data=df_year, marker='o')
plt.title('Applications Over Years')
plt.show()

df_uni = merged.groupby('Uni_ID')['Schol_ID'].nunique().reset_index().sort_values('Schol_ID', ascending=False)
df_uni.head(10).plot(kind='bar', x='Uni_ID', y='Schol_ID', color='orange', legend=False)
plt.title('Top 10 Universities Offering Scholarships')
plt.show()